//
// key.src - key double-click script
//
// There are two kinds of keys.  The older has a custom property "target_id"
// which is the serial number of the item it is allowed to open.  This doesn't
// allow a key to unlock more than one thing (such as both planks of a boat).
// It also doesn't allow simple changing of locks.
//
//	Not any more. :-)  They're all lockid-style keys now.
//	I suppose owners of older keys will have to page a GM
//	to get their stuff .rekey'd.  
//
//	Added targeting the key to rename it and targeting another key (with 
//	a blank one) to make a copy.
//		-Dundee
//
// The newer kind of key has a custom property "lockid" which is an increasing
// global counter generated by AllocLockId (include/utility.inc).  The locked object
// also has a lockid.  To change the locks, just change the lockid on the locked
// object; old keys are automatically invalidated.  To have a key fit more than
// one door/plank/chest, set the lockid of the locked objects to be the same.
//
//	I put keyring code here and used npcbackpack code to make a storage area
//		-Dundee
//
//Added to config/itemdesc.cfg:
//
// Item 0x1011
// {
//	Name            keyring
//	Script          key
//	VendorSellsFor  12
//	VendorBuysFor   4
// }
//

use uo;
include "include/objtype";
include "include/utility";

program use_key (character, key)
	var thetarget := Target (character);
	if (!Accessible (character, thetarget))
		PrintTextAbovePrivate (character, "You can't reach that", character);
		return;
	endif
	if (thetarget.objtype == 0x1F01A)
		thetarget := thetarget.multi.hold;
	elseif (thetarget.objtype == 0x1F014)
		thetarget := thetarget.multi.wheel[1];
	endif

	//Make sure that they're not locking the key within the container
	if (thetarget.isa (POLCLASS_CONTAINER))
		if (InInventory (thetarget, key))
			SendSysMessage (character, "But that would lock the key inside of the container!");
			return;
		endif
	endif

	if (key.objtype == UOBJ_KEY_RING)
		UseKeyRing (character, key, thetarget);
		return;
	elseif (thetarget == key)
		RenameKey ( character, key );
		return;
	endif

	var lockid := GetObjProperty( key, "lockid" );
	var targetlockid := GetObjProperty (thetarget, "lockid");

	if (!targetlockid)
		PrintTextAbovePrivate (thetarget, "That doesn't have a lock.", character);
		return;
	endif

	if (!lockid)
		CopyKey (character, key, thetarget);
		return;
	endif

	if (lockid != targetlockid)
		PrintTextAbovePrivate (thetarget, "That's the wrong key!", character);
		return;
	else
		if (thetarget.objtype >= UOBJ_KEY_START and thetarget.objtype <= UOBJ_KEY_END)
			PrintTextAbovePrivate (character, "These keys match", character);
			return;
		elseif (thetarget.objtype == 0x1F015)
			LockShip (thetarget, character);
		else
			UnLockIt(thetarget,character);
			return;
		endif
	endif
endprogram




///////////////////
//  Does the actual locking and unlocking
///////////////////

function UnLockIt (thetarget, character)
	if (thetarget.locked)
		PrintTextAbovePrivate (thetarget, "You unlock it.", character);
		thetarget.locked := 0;
	else
		PrintTextAbovePrivate (thetarget, "You lock it.", character);
		thetarget.locked := 1;
	endif
endfunction

function LockShip (thetarget, character)
	var locked := GetObjProperty(thetarget, "locked");
	if (locked)
		PrintTextAbovePrivate (thetarget, "You unlock it.", character);
		SetObjProperty(thetarget, "locked", 0);
	else
		PrintTextAbovePrivate (thetarget, "You lock it.", character);
		SetObjProperty(thetarget, "locked", 1);
	endif
endfunction



///////////////////
//  Complicated stuff for keyrings
///////////////////

function UseKeyRing (character, key, thetarget)
	var insidering := FindMyPack (key.serial);

	//target the keyring to dump the contents all over your pack
	if (key == thetarget)
		PrintTextAbovePrivate (character, "You remove the keys from the ring.", character);
		foreach otherkey in EnumerateItemsInContainer (insidering)
			if (!MoveItemToContainer (otherkey, character.backpack))
				MoveObjectToLocation( otherkey, character.x, character.y, character.z, character.realm, MOVEOBJECT_FORCELOCATION );
			endif
		endforeach
		key.graphic := 4113;
		return;
	endif

	var targetlockid := GetObjProperty (thetarget, "lockid");
	//exit if the target is not a lock or is a blank key
	if (!targetlockid)
		PrintTextAbovePrivate (thetarget, "That doesn't have a lock.", character );
		return;
	endif

	//if the target is a key, move it into the keyring, otherwise try to unlock it
	if ( (thetarget.objtype >= UOBJ_KEY_START) and (thetarget.objtype <= UOBJ_KEY_END) and (thetarget.objtype != UOBJ_KEY_RING ))
		PrintTextAbovePrivate (character, "You put the key on the keyring.", character );
		MoveItemToContainer (thetarget, insidering);
		if (!key.graphic)
			key.graphic := 4113;
		endif
		if (key.graphic == 4113)
			key.graphic := 5993;
		elseif (key.graphic < 5995)
			key.graphic := key.graphic + 1;
		endif
		return;
	endif
	
	//check the lockid of all the keyring's contents against the lock
	foreach otherkey in EnumerateItemsInContainer (insidering)
		var lockid := GetObjProperty (otherkey, "lockid");
		if (lockid == targetlockid)
			if (thetarget.objtype == 0x1F015)
				LockShip (thetarget, character);
			else
				UnlockIt (thetarget, character);
			endif
			return;
		endif
	endforeach

	PrintTextAbovePrivate (key, "None of your keys fit that lock.", character);
	return;
endfunction

function RenameKey (character, key)
	var keyDescription := RequestInput (character, key, 
		"Please enter a description for this key. (max 20 characters)" );

    	var descriptionLen := Len( keyDescription );
	if ( keyDescription )
		if (descriptionLen <= 20)
			key.name := "a key: "+ keyDescription;			
			SendSysMessage (character, "Key is renamed.");
		else
			SendSysMessage (character, "That name is too long");
		endif
	endif

endfunction

function CopyKey (character, key, thetarget)
	var targetlockid := GetObjProperty (thetarget, "lockid");

	if ( (thetarget.objtype >= UOBJ_KEY_START) and (thetarget.objtype <= UOBJ_KEY_END) )
		SetObjProperty( key, "lockid", targetlockid );
		if (thetarget.name)
			key.name := thetarget.name;
		endif
		PrintTextAbovePrivate( key, "You make a copy of the key", character );
	else
		PrintTextAbovePrivate( key, "This key is blank", character );
	endif
endfunction







function OpenTamedStorageAreas()

    var bank := FindStorageArea( "Tamed Storage" );
    if (!bank)
        bank := CreateStorageArea( "Tamed Storage" );
    endif

    return bank;

endfunction

function FindMyPack(myserial)

    var mybank := OpenTamedStorageAreas ();
    var bank_obj_name := "Bankbox  " + hex(myserial);
    var bankbox := FindRootItemInStorageArea( mybank, bank_obj_name );

    if (!bankbox)
        bankbox := CreateRootItemInStorageArea(mybank, bank_obj_name, UOBJ_BANKBOX  );
    endif
    
    return bankbox;

endfunction
